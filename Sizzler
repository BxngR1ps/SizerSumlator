-- Load the existing script
loadstring(game:HttpGet('https://pastebin.com/raw/cwDSpepQ', true))()

local first = library:AddWindow('SizerSumlator - by KðŸŒ¹rl')
local first_tab = first:AddTab('github/BxngR1ps')

-- Variables for switches
local this_game_sucks = false
local meat = false
local coin = false

-- Add switches for gameplay control
first_tab:AddSwitch('Auto Defeat Chickens (Random)', function(a)
    this_game_sucks = a
end)

first_tab:AddSwitch('Auto Collect Meat (every Meat)', function(a)
    meat = a
end)

first_tab:AddSwitch('Auto Farm Coins', function(a)
    coin = a
end)

-- Adding a button for Infinite Yield execution
first_tab:AddButton('Click All (Useful)', function()
	local player = game.Players.LocalPlayer
	local char = player.Character or player.CharacterAdded:Wait()
	local root = char:WaitForChild("HumanoidRootPart")

	for _, v in ipairs(workspace:GetDescendants()) do
		if v:IsA("TouchTransmitter") or v.Name == "TouchInterest" then
			firetouchinterest(root, v.Parent, 0)
			firetouchinterest(root, v.Parent, 1)
		end
	end

	game:GetService("StarterGui"):SetCore("SendNotification", {
		Title = "Click Everything",
		Text = "lul but useful",
		Icon = "rbxassetid://86501960555905"
	})
end)

-- Remote event setup
local RemoteEvent = game:GetService("ReplicatedStorage").RemoteEvent
local TweenService = game:GetService("TweenService")

local last = math.huge
local nearest = nil
local id = nil

-- smooth auto chicken
spawn(function()
	while task.wait(1) do
		if this_game_sucks then
			last, nearest, id = math.huge, nil, nil
			for _, v in pairs(workspace:GetChildren()) do	
				if v:FindFirstChild('CharId') and v:FindFirstChildWhichIsA('Part') then
					local part = v:FindFirstChildWhichIsA('Part')
					local dist = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - part.Position).Magnitude
					if dist < last then
						last = dist
						nearest = part
						id = v.CharId.Value
					end
				end
			end
		else
			last, nearest, id = math.huge, nil, nil
		end
	end
end)

spawn(function()
	while task.wait() do
		if nearest and id and this_game_sucks then
			local hrp = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
			if not hrp then continue end

			RemoteEvent:FireServer("Animal Selected", id)

			-- tween move towards the chicken
			local target = nearest.CFrame * CFrame.new(0, 2, 0)
			local tween = TweenService:Create(hrp, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = target})
			tween:Play()
			tween.Completed:Wait()

			-- send hits while near chicken
			if nearest and nearest.Parent and nearest.Parent:FindFirstChild("CharId") and this_game_sucks then
				for i = 1, 10 do
					RemoteEvent:FireServer("Animal Hit", id)
					task.wait(0.05)
				end
			else
				last, nearest, id = math.huge, nil, nil
			end
		end
	end
end)

-- meat + coins stays same (safe)
spawn(function()
	while task.wait() do
		local player = game.Players.LocalPlayer
		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then continue end

		if meat then
			for i, v in pairs(workspace:GetChildren()) do 
				if string.find(v.Name:lower(), "meat") and v.Name ~= "DropOffMeat" and v:FindFirstChild("Main") then
					v.Main.CFrame = hrp.CFrame
				end
			end
			RemoteEvent:FireServer('Drop Off Meat')
			RemoteEvent:FireServer('Collect Grill Coins')
		end

		if coin then
			for i, v in pairs(workspace.Currency:GetChildren()) do
				local p = v:FindFirstChildWhichIsA('Part')
				if p and p:FindFirstChild('TouchInterest') then
					p.CFrame = hrp.CFrame
				end
			end
		end
	end
end)
-- Create a second tab for additional features
local second_tab = first:AddTab('Extras')

local player = game.Players.LocalPlayer
-- Wait for character to load
local character = player.Character or player.CharacterAdded:Wait()
local spinning = false
local spinSpeed = 10 -- Speed at which to spin

-- Function to start spinning
local function startSpinning()
    spinning = true
    while spinning do
        wait(0) -- Lower the wait time for smoother spinning
        if character and character:FindFirstChild("HumanoidRootPart") then
            -- Rotate the HumanoidRootPart
            character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed), 0)
        end
    end
end

-- Function to stop spinning
local function stopSpinning()
    spinning = false
end

-- Adding the Spin switch to the UI
second_tab:AddSwitch('Spin', function(svalue)
    if svalue then
        startSpinning() -- Start spinning when switch is on
    else
        stopSpinning() -- Stop spinning when switch is off
    end
end)

local player = game.Players.LocalPlayer
local UIS = game:GetService("UserInputService")
local flying = false
local speed = 50 -- Speed at which the player flies
local bodyVelocity

local function startFlying()
    flying = true
    player.Character.Humanoid.PlatformStand = true  -- Prevents the player from falling
    bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000) -- Adjust force to your liking
    bodyVelocity.Parent = player.Character.PrimaryPart

    -- Control flying with keyboard input
    while flying do
        wait(0.1)
        
        local direction = Vector3.new(0, 0, 0)
        
        if UIS:IsKeyDown(Enum.KeyCode.W) then
            direction = direction + workspace.CurrentCamera.CFrame.LookVector
        end
        if UIS:IsKeyDown(Enum.KeyCode.S) then
            direction = direction - workspace.CurrentCamera.CFrame.LookVector
        end
        if UIS:IsKeyDown(Enum.KeyCode.A) then
            direction = direction - workspace.CurrentCamera.CFrame.RightVector
        end
        if UIS:IsKeyDown(Enum.KeyCode.D) then
            direction = direction + workspace.CurrentCamera.CFrame.RightVector
        end
        if UIS:IsKeyDown(Enum.KeyCode.Space) then
            direction = direction + Vector3.new(0, 1, 0) -- Move up
        end
        if UIS:IsKeyDown(Enum.KeyCode.LeftControl) then
            direction = direction - Vector3.new(0, 1, 0) -- Move down
        end
        
        bodyVelocity.Velocity = direction * speed
    end

    -- Cleanup
    bodyVelocity:Destroy()
    player.Character.Humanoid.PlatformStand = false
end

local function stopFlying()
    flying = false
end

-- Adding a fly toggle switch to the second tab
second_tab:AddSwitch('Fly', function(value)
    if value then
        startFlying()
    else
        stopFlying()
    end
end)

local player = game.Players.LocalPlayer

local function updateWalkSpeed(value)
    player.Character.Humanoid.WalkSpeed = value
end

-- Create a slider for WalkSpeed
second_tab:AddSlider('WalkSpeed', function(value)
    updateWalkSpeed(value)
end)

-- Initialize the WalkSpeed to the default value
updateWalkSpeed(16)

-- Anti-AFK Script

local player = game.Players.LocalPlayer
local userInputService = game:GetService("UserInputService")

-- Function to simulate player activity
local function keepActive()
    while wait(10) do -- Adjust the wait time as needed
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            -- Move player slightly to simulate activity
            player.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, -0.1)
        end
    end
end

-- Create a toggle for the Anti-AFK in the GUI
second_Tab:AddToggle('Toggle Anti-AFK', false, function(state)
    if state then
        keepActive() -- Start the anti-AFK loop
    else
        -- You can create a method to safely stop the anti-AFK if needed
        -- If the anti-AFK is running in a separate function, implement a way to stop it
    end
end)
