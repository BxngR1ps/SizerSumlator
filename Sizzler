-- Load the existing script
loadstring(game:HttpGet('https://pastebin.com/raw/cwDSpepQ', true))()

local first = library:AddWindow('SizerSumlator - by KðŸŒ¹rl')
local first_tab = first:AddTab('Main Tab')

-- Variables for switches
local this_game_sucks = false
local meat = false
local coin = false
local Vip = false

-- Add switches for gameplay control
first_tab:AddSwitch('Auto Fight (Random)', function(a)
    this_game_sucks = a
end)

first_tab:AddSwitch('Auto Collect Meat (every Meat)', function(a)
    meat = a
end)

first_tab:AddSwitch('Auto Farm Coins', function(a)
    coin = a
end)

first_tab:AddSwitch('Fake Vip', function(a)
    Vip = a
end)


spawn(function()
	while task.wait(1) do
		if Vip then
			workspace.VIPWindow.Main.CanCollide = Vip
	end
end)

-- Adding a button for Infinite Yield execution
first_tab:AddButton('Click All (Useful)', function()
	local player = game.Players.LocalPlayer
	local char = player.Character or player.CharacterAdded:Wait()
	local root = char:WaitForChild("HumanoidRootPart")

	for _, v in ipairs(workspace:GetDescendants()) do
		if v:IsA("TouchTransmitter") or v.Name == "TouchInterest" then
			firetouchinterest(root, v.Parent, 0)
			firetouchinterest(root, v.Parent, 1)
		end
	end

	game:GetService("StarterGui"):SetCore("SendNotification", {
		Title = "Click Everything",
		Text = "lul but useful",
		Icon = "rbxassetid://86501960555905"
	})
end)

-- Remote event setup
local RemoteEvent = game:GetService("ReplicatedStorage").RemoteEvent
local TweenService = game:GetService("TweenService")

local last = math.huge
local nearest = nil
local id = nil

-- smooth auto chicken
spawn(function()
	while task.wait(1) do
		if this_game_sucks then
			last, nearest, id = math.huge, nil, nil
			for _, v in pairs(workspace:GetChildren()) do	
				if v:FindFirstChild('CharId') and v:FindFirstChildWhichIsA('Part') then
					local part = v:FindFirstChildWhichIsA('Part')
					local dist = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - part.Position).Magnitude
					if dist < last then
						last = dist
						nearest = part
						id = v.CharId.Value
					end
				end
			end
		else
			last, nearest, id = math.huge, nil, nil
		end
	end
end)

spawn(function()
	while task.wait() do
		if nearest and id and this_game_sucks then
			local player = game.Players.LocalPlayer
			local char = player.Character
			local hrp = char and char:FindFirstChild("HumanoidRootPart")
			if not hrp then continue end

			RemoteEvent:FireServer("Animal Selected", id)

			local targetPos = nearest.Position + Vector3.new(0, 2, 0)
			local stepSize = 0.35 -- how smooth the slide feels (lower = smoother / slower)
			local maxDist = 20    -- prevent big jumps

			-- smooth move toward target without teleport snapping
			if (hrp.Position - targetPos).Magnitude > 2 then
				local direction = (targetPos - hrp.Position).Unit
				local moveDist = math.min((hrp.Position - targetPos).Magnitude, maxDist)
				local goalPos = hrp.Position + direction * moveDist * stepSize
				hrp.CFrame = CFrame.new(goalPos, targetPos) -- face the target
			end

			-- while close enough, do the hits
			if (hrp.Position - targetPos).Magnitude < 8 then
				for i = 1, 10 do
					if not this_game_sucks then break end
					RemoteEvent:FireServer("Animal Hit", id)
					task.wait(0.05)
				end
			end
		else
			last, nearest, id = math.huge, nil, nil
		end
	end
end)

spawn(function()
	while task.wait(0.25) do
		local player = game.Players.LocalPlayer
		local char = player.Character or player.CharacterAdded:Wait()
		local hrp = char:FindFirstChild("HumanoidRootPart")
		if not hrp then continue end

		-- auto meat collect
		if meat then
			for _, v in pairs(workspace:GetChildren()) do
				if v:IsA("Model") and string.find(v.Name:lower(), "meat") and v.Name ~= "DropOffMeat" then
					local main = v:FindFirstChild("Main") or v:FindFirstChildWhichIsA("BasePart")
					if main and not main.Anchored then
						-- soft pull toward player
						main.CFrame = main.CFrame:Lerp(hrp.CFrame, 0.35)
					end
				end
			end

			pcall(function()
				RemoteEvent:FireServer("Drop Off Meat")
				RemoteEvent:FireServer("Collect Grill Coins")
			end)
		end

		-- auto coin collect
		if coin and workspace:FindFirstChild("Currency") then
			for _, v in pairs(workspace.Currency:GetChildren()) do
				local p = v:FindFirstChildWhichIsA("BasePart")
				if p and p:FindFirstChild("TouchInterest") then
					-- small lerp instead of hard snap
					p.CFrame = p.CFrame:Lerp(hrp.CFrame, 0.5)
				end
			end
		end
	end
end)

-- Create a second tab for additional features
local second_tab = first:AddTab('Extras Tab - github/BxngR1ps')

local player = game.Players.LocalPlayer
-- Wait for character to load
local character = player.Character or player.CharacterAdded:Wait()
local spinning = false
local spinSpeed = 10 -- Speed at which to spin

-- Function to start spinning
local function startSpinning()
    spinning = true
    while spinning do
        wait(0) -- Lower the wait time for smoother spinning
        if character and character:FindFirstChild("HumanoidRootPart") then
            -- Rotate the HumanoidRootPart
            character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed), 0)
        end
    end
end

-- Function to stop spinning
local function stopSpinning()
    spinning = false
end

-- Adding the Spin switch to the UI
second_tab:AddSwitch('Spin', function(svalue)
    if svalue then
        startSpinning() -- Start spinning when switch is on
    else
        stopSpinning() -- Stop spinning when switch is off
    end
end)

local player = game.Players.LocalPlayer
local UIS = game:GetService("UserInputService")
local flying = false
local speed = 50 -- Speed at which the player flies
local bodyVelocity

local function startFlying()
    flying = true
    player.Character.Humanoid.PlatformStand = true  -- Prevents the player from falling
    bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000) -- Adjust force to your liking
    bodyVelocity.Parent = player.Character.PrimaryPart

    -- Control flying with keyboard input
    while flying do
        wait(0.1)
        
        local direction = Vector3.new(0, 0, 0)
        
        if UIS:IsKeyDown(Enum.KeyCode.W) then
            direction = direction + workspace.CurrentCamera.CFrame.LookVector
        end
        if UIS:IsKeyDown(Enum.KeyCode.S) then
            direction = direction - workspace.CurrentCamera.CFrame.LookVector
        end
        if UIS:IsKeyDown(Enum.KeyCode.A) then
            direction = direction - workspace.CurrentCamera.CFrame.RightVector
        end
        if UIS:IsKeyDown(Enum.KeyCode.D) then
            direction = direction + workspace.CurrentCamera.CFrame.RightVector
        end
        if UIS:IsKeyDown(Enum.KeyCode.Space) then
            direction = direction + Vector3.new(0, 1, 0) -- Move up
        end
        if UIS:IsKeyDown(Enum.KeyCode.LeftControl) then
            direction = direction - Vector3.new(0, 1, 0) -- Move down
        end
        
        bodyVelocity.Velocity = direction * speed
    end

    -- Cleanup
    bodyVelocity:Destroy()
    player.Character.Humanoid.PlatformStand = false
end

local function stopFlying()
    flying = false
end

-- Adding a fly toggle switch to the second tab
second_tab:AddSwitch('Fly', function(value)
    if value then
        startFlying()
    else
        stopFlying()
    end
end)

local player = game.Players.LocalPlayer

local function updateWalkSpeed(value)
    player.Character.Humanoid.WalkSpeed = value
end

-- Create a slider for WalkSpeed
second_tab:AddSlider('WalkSpeed', function(value)
    updateWalkSpeed(value)
end)

-- Initialize the WalkSpeed to the default value
updateWalkSpeed(16)

-- Anti-AFK Script

local player = game.Players.LocalPlayer
local userInputService = game:GetService("UserInputService")

-- Function to simulate player activity
local function keepActive()
    while wait(10) do -- Adjust the wait time as needed
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            -- Move player slightly to simulate activity
            player.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, -0.1)
        end
    end
end

-- Create a toggle for the Anti-AFK in the GUI
second_Tab:AddToggle('Toggle Anti-AFK', false, function(state)
    if state then
        keepActive() -- Start the anti-AFK loop
    else
        -- You can create a method to safely stop the anti-AFK if needed
        -- If the anti-AFK is running in a separate function, implement a way to stop it
    end
end)
